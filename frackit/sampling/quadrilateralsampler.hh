// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
// vi: set et ts=4 sw=4 sts=4:
/*****************************************************************************
 *   See the file COPYING for full copying permissions.                      *
 *                                                                           *
 *   This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation, either version 3 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
 *****************************************************************************/
/*!
 * \file
 * \ingroup Sampling
 * \brief Class to randomly generate quadrilaterals in n-dimensional space.
 */
#ifndef FRACKIT_QUADRILATERAL_SAMPLER_HH
#define FRACKIT_QUADRILATERAL_SAMPLER_HH

#include <memory>
#include <random>
#include <type_traits>

#include <frackit/common/math.hh>
#include <frackit/precision/precision.hh>

#include <frackit/geometry/point.hh>
#include <frackit/geometry/vector.hh>
#include <frackit/geometry/direction.hh>
#include <frackit/geometry/quadrilateral.hh>

#include "pointsampler.hh"
#include "geometrysampler.hh"

namespace Frackit {

//! Forward declaration of the default traits class.
template<class ctype, int worldDim>
struct DefaultQuadrilateralSamplerTraits;

/*!
 * \ingroup Sampling
 * \brief Default traits class for sampling quadrilaterals in 3d space.
 *        Uses uniform distributions for all parameters.
 */
template<class ctype>
struct DefaultQuadrilateralSamplerTraits<ctype, 3>
{
    // Orientation of the quadrilateral plane within the x-y plane
    using StrikeAngleDistribution = std::normal_distribution<ctype>;

    // Dip angle of the quadrilateral plane measured against the x-y plane
    using DipAngleDistribution = std::normal_distribution<ctype>;

    // Distribution used for the lengths of the quardilateral edges
    using EdgeLengthDistribution = std::normal_distribution<ctype>;
};

//! Forward declaration of the dimension-specific sampler class for quadrilaterals
template< int worldDim,
          class ctype = double,
          class T = DefaultQuadrilateralSamplerTraits<ctype, worldDim> >
class QuadrilateralSampler;

/*!
 * \ingroup Sampling
 * \brief Sampler for quadrilaterals in 3d space.
 *        The quadrilaterals are generated by sampling from provided
 *        distributions for:
 *            - strike angle (angle between x-axis and plane intersection with x-y-plane)
 *            - dip angle (angle between the x-y-plane and the plane of the quadrilateral)
 *            - the lengths of the quadrilateral edges
 */
template< class ctype, class T >
class QuadrilateralSampler<3, ctype, T>
: public GeometrySampler< Quadrilateral<ctype, 3> >
{
    using StrikeDistribution = typename T::StrikeAngleDistribution;
    using DipDistribution = typename T::DipAngleDistribution;
    using EdgeDistribution = typename T::EdgeLengthDistribution;

    using Point = Frackit::Point<ctype, 3>;
    using Vector = Frackit::Vector<ctype, 3>;
    using Direction = Frackit::Direction<ctype, 3>;

public:
    //! export underlying geometry type
    using Quadrilateral = Frackit::Quadrilateral<ctype, 3>;
    using Geometry = Quadrilateral;

    //! export traits class
    using Traits = T;

    /*!
     * \brief Constructor.
     * \param pointSampler Point sampler object to sample center points
     * \param strikeDistro The distribution used for the strike angle
     * \param dipDistro The distribution used for the dip angle
     * \param edgeDistro The distribution used for the edge length
     * \param minEdgeLength Minimum allowed edge length
     * \note The edge distribution is sampled until an admissible value
     *       above the minimum allowed edge length is obtained. Thus,
     *       if you choose a high minimum length, depending on the chosen
     *       edge length distribution, you might end up with very inefficient
     *       sampling, or, in the worst case, an infinite loop is created
     *       in the sampling procedure implemented in the () operator.
     */
    template<class PointSamplerImpl>
    QuadrilateralSampler(const PointSamplerImpl& pointSampler,
                         const StrikeDistribution& strikeDistro,
                         const DipDistribution& dipDistro,
                         const EdgeDistribution& edgeDistro,
                         ctype minEdgeLength = Precision<ctype>::confusion())
    : pointSampler_(std::make_shared<PointSamplerImpl>(pointSampler))
    , generator_(std::random_device{}())
    , p_strike_(strikeDistro)
    , p_dip_(dipDistro)
    , p_edge_(edgeDistro)
    , minEdgeLength_(minEdgeLength)
    {
        static_assert(std::is_base_of<PointSampler<Point>, PointSamplerImpl>::value,
                      "The provided point sampler does not inherit from the point sampler interface");
    }

    /*!
     * \brief Generate a random quadrilateral.
     */
    Quadrilateral operator() () override
    {
        const auto strike = p_strike_(generator_);
        const auto dip = p_dip_(generator_);

        // get the basis of the plane within the x-y-plane by
        // rotation around the z-axis with the strike angle
        std::vector<Vector> axes({Vector(1.0, 0.0, 0.0),
                                  Vector(0.0, 1.0, 0.0)});
        rotate(axes, Direction(Vector(0.0, 0.0, 1.0)), strike);

        // rotate base1 around base2 with the dip angle
        rotate(axes[0], Direction(axes[1]), dip);

        // sample edge lengths until all are admissible
        auto dx1 = p_edge_(generator_); while (dx1 < minEdgeLength_) p_edge_(generator_);
        auto dx2 = p_edge_(generator_); while (dx2 < minEdgeLength_) p_edge_(generator_);
        auto dy1 = p_edge_(generator_); while (dy1 < minEdgeLength_) p_edge_(generator_);
        auto dy2 = p_edge_(generator_); while (dy2 < minEdgeLength_) p_edge_(generator_);

        auto dxVec1 = axes[0]; dxVec1 *= dx1/2.0;
        auto dxVec2 = axes[0]; dxVec2 *= dx2/2.0;
        auto dyVec1 = axes[1]; dyVec1 *= dy1/2.0;
        auto dyVec2 = axes[1]; dyVec2 *= dy2/2.0;

        // compute corner points
        const auto c = (*pointSampler_)();
        auto c1 = c; c1 -= dxVec1; c1 -= dyVec1;
        auto c2 = c; c2 += dxVec1; c2 -= dyVec2;
        auto c3 = c; c3 -= dxVec2; c3 += dyVec1;
        auto c4 = c; c4 += dxVec2; c4 += dyVec2;

        return Quadrilateral(c1, c2, c3, c4);
    }

 private:
    std::shared_ptr<PointSampler<Point>> pointSampler_; //!< pointer to the sampler for quadrilateral center points
    std::default_random_engine generator_;              //!< Random number generator

    StrikeDistribution p_strike_; //!< Distribution used for the strike angle
    DipDistribution p_dip_;       //!< Distribution used for the dip angle
    EdgeDistribution p_edge_;     //!< Distribution used for the edge lengths of the quads
    ctype minEdgeLength_;         //!< Minimum allowed length of quadrilateral edges
};

} // end namespace Frackit

#endif // FRACKIT_QUADRILATERAL_SAMPLER_HH
