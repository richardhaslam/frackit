// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
// vi: set et ts=4 sw=4 sts=4:
/*****************************************************************************
 *   See the file COPYING for full copying permissions.                      *
 *                                                                           *
 *   This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation, either version 3 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
 *****************************************************************************/
/*!
 * \file
 * \ingroup Sampling
 * \brief Class to randomly generate quadrilaterals in n-dimensional space.
 */
#ifndef FRACKIT_QUADRILATERAL_SAMPLER_HH
#define FRACKIT_QUADRILATERAL_SAMPLER_HH

#include <memory>
#include <random>
#include <type_traits>

#include <frackit/common/math.hh>
#include <frackit/precision/precision.hh>

#include <frackit/geometry/point.hh>
#include <frackit/geometry/vector.hh>
#include <frackit/geometry/direction.hh>
#include <frackit/geometry/quadrilateral.hh>

#include "pointsampler.hh"
#include "geometrysampler.hh"
#include "polygonsampler.hh"

namespace Frackit {

//! Forward declaration of the default traits class.
template<class ctype, int worldDim>
struct DefaultQuadrilateralSamplerTraits;

/*!
 * \ingroup Sampling
 * \brief Default traits class for sampling quadrilaterals in 3d space.
 *        Uses uniform distributions for all parameters.
 */
template<class ctype>
struct DefaultQuadrilateralSamplerTraits<ctype, 3>
{
    // Orientation of the quadrilateral plane within the x-y plane
    using StrikeAngleDistribution = std::normal_distribution<ctype>;

    // Dip angle of the quadrilateral plane measured against the x-y plane
    using DipAngleDistribution = std::normal_distribution<ctype>;

    // Distributions for the sizes (lengths) of the quardilateral in the two directions
    using StrikeLengthDistribution = std::uniform_real_distribution<ctype>;
    using DipLengthDistribution = std::uniform_real_distribution<ctype>;
};

//! Forward declaration of the dimension-specific sampler class for quadrilaterals
template< int worldDim,
          class ctype = double,
          class T = DefaultQuadrilateralSamplerTraits<ctype, worldDim> >
class QuadrilateralSampler;

// forward declaration of the deprecated implementation
namespace Detail {

template< class ctype, class T >
struct DeprecatedQuadSamplerTraits : public T
{ using EdgeLengthDistribution  = std::normal_distribution<ctype>; };

template< class ctype, class T >
class DeprecatedQuadrilateralSamplerImpl;

} // end namespace Detail

/*!
 * \ingroup Sampling
 * \brief Sampler for quadrilaterals in 3d space.
 *        The quadrilaterals are generated by sampling from provided
 *        distributions for:
 *            - strike angle (angle between x-axis and quadrilateral intersection with x-y-plane)
 *            - dip angle (angle between the x-y-plane and the plane of the quadrilateral)
 *            - the dimensions of the quadrilaterals in strike- and dip-direction
 * \note Internally, this uses an instance of the polygon sampler class
 *       with a distribution that results in a fixed number of corners (namely 4).
 */
template< class ctype, class T >
class QuadrilateralSampler<3, ctype, T>
: public GeometrySampler< Quadrilateral<ctype, 3> >
{
    struct PolygonSamplerTraits : public T
    { using NumCornersDistribution = std::uniform_int_distribution<int>; };

    using PolygonSampler = Frackit::PolygonSampler<3, ctype, PolygonSamplerTraits>;
    using CornerDistro = typename PolygonSamplerTraits::NumCornersDistribution;

    //! underlying distributions
    using StrikeAngleDistribution = typename T::StrikeAngleDistribution;
    using DipAngleDistribution = typename T::DipAngleDistribution;
    using StrikeLengthDistribution = typename T::StrikeLengthDistribution;
    using DipLengthDistribution = typename T::DipLengthDistribution;

    using Point = Frackit::Point<ctype, 3>;

    // deprecated, but still supported old sampler implementation
    using DT = Detail::DeprecatedQuadSamplerTraits<ctype, T>;
    using DeprecatedSampler = Detail::DeprecatedQuadrilateralSamplerImpl<ctype, DT>;

public:
    //! export underlying geometry type
    using Quadrilateral = Frackit::Quadrilateral<ctype, 3>;
    using Geometry = Quadrilateral;

    //! export traits class
    using Traits = T;

    /*!
     * \brief Constructor of the deprecated implementation.
     */
    template<class PointSamplerImpl>
    [[deprecated("will be removed after release 1.2. Please use new constructor/implementation!")]]
    QuadrilateralSampler(const PointSamplerImpl& pointSampler,
                         const StrikeAngleDistribution& strikeAngleDistro,
                         const DipAngleDistribution& dipAngleDistro,
                         const typename DT::EdgeLengthDistribution& edgeLengthDistro,
                         ctype minEdgeLength = Precision<ctype>::confusion())
    : deprecatedSampler_(std::make_shared<DeprecatedSampler>(pointSampler,
                                                             strikeAngleDistro, dipAngleDistro,
                                                             edgeLengthDistro, minEdgeLength))
    {}

    /*!
     * \brief The constructor.
     * \param pointSampler Point sampler object to sample center points
     * \param strikeAngleDistro The distribution used for the strike angle
     * \param dipAngleDistro The distribution used for the dip angle
     * \param strikeLengthDistro The distribution used for the size in strike direction
     * \param dipLengthDistro The distribution used for the size in dip direction
     */
    template<class PointSamplerImpl>
    QuadrilateralSampler(const PointSamplerImpl& pointSampler,
                         const StrikeAngleDistribution& strikeAngleDistro,
                         const DipAngleDistribution& dipAngleDistro,
                         const StrikeLengthDistribution& strikeLengthDistro,
                         const DipLengthDistribution& dipLengthDistro)
    : polygonSampler_(std::make_shared<PolygonSampler>(pointSampler,
                                                       strikeAngleDistro, dipAngleDistro,
                                                       strikeLengthDistro, dipLengthDistro,
                                                       CornerDistro{4, 4}))
    {}

    /*!
     * \brief Generate a random quadrilateral.
     */
    Quadrilateral operator() () override
    {
        if (polygonSampler_)
        {
            const auto corners = polygonSampler_->sampleCorners();
            assert(corners.size() == 4);
            return Quadrilateral(corners[0], corners[1], corners[3], corners[2]);
        }

        // TODO: Remove after deprecation period
        else
            return (*deprecatedSampler_)();
    }

 private:
    std::shared_ptr<PolygonSampler> polygonSampler_ = nullptr;
    std::shared_ptr<DeprecatedSampler> deprecatedSampler_ = nullptr;
};

namespace Detail {

template< class ctype, class T >
class DeprecatedQuadrilateralSamplerImpl
: public GeometrySampler< Quadrilateral<ctype, 3> >
{
    using StrikeDistribution = typename T::StrikeAngleDistribution;
    using DipDistribution = typename T::DipAngleDistribution;
    using EdgeDistribution = typename T::EdgeLengthDistribution;

    using Point = Frackit::Point<ctype, 3>;
    using Vector = Frackit::Vector<ctype, 3>;
    using Direction = Frackit::Direction<ctype, 3>;

public:
    //! export underlying geometry type
    using Quadrilateral = Frackit::Quadrilateral<ctype, 3>;
    using Geometry = Quadrilateral;

    //! export traits class
    using Traits = T;

    /*!
     * \brief Constructor.
     * \param pointSampler Point sampler object to sample center points
     * \param strikeDistro The distribution used for the strike angle
     * \param dipDistro The distribution used for the dip angle
     * \param edgeDistro The distribution used for the edge length
     * \param minEdgeLength Minimum allowed edge length
     * \note The edge distribution is sampled until an admissible value
     *       above the minimum allowed edge length is obtained. Thus,
     *       if you choose a high minimum length, depending on the chosen
     *       edge length distribution, you might end up with very inefficient
     *       sampling, or, in the worst case, an infinite loop is created
     *       in the sampling procedure implemented in the () operator.
     */
    template<class PointSamplerImpl>
    DeprecatedQuadrilateralSamplerImpl(const PointSamplerImpl& pointSampler,
                                       const StrikeDistribution& strikeDistro,
                                       const DipDistribution& dipDistro,
                                       const EdgeDistribution& edgeDistro,
                                       ctype minEdgeLength = Precision<ctype>::confusion())
    : pointSampler_(std::make_shared<PointSamplerImpl>(pointSampler))
    , generator_(std::random_device{}())
    , p_strike_(strikeDistro)
    , p_dip_(dipDistro)
    , p_edge_(edgeDistro)
    , minEdgeLength_(minEdgeLength)
    {
        static_assert(std::is_base_of<PointSampler<Point>, PointSamplerImpl>::value,
                      "The provided point sampler does not inherit from the point sampler interface");
    }

    /*!
     * \brief Generate a random quadrilateral.
     */
    Quadrilateral operator() () override
    {
        const auto strike = p_strike_(generator_);
        const auto dip = p_dip_(generator_);

        // get the basis of the plane within the x-y-plane by
        // rotation around the z-axis with the strike angle
        std::vector<Vector> axes({Vector(1.0, 0.0, 0.0),
                                  Vector(0.0, 1.0, 0.0)});
        rotate(axes, Direction(Vector(0.0, 0.0, 1.0)), strike);

        // rotate base1 around base2 with the dip angle
        rotate(axes[0], Direction(axes[1]), dip);

        // sample edge lengths until all are admissible
        auto dx1 = p_edge_(generator_); while (dx1 < minEdgeLength_) p_edge_(generator_);
        auto dx2 = p_edge_(generator_); while (dx2 < minEdgeLength_) p_edge_(generator_);
        auto dy1 = p_edge_(generator_); while (dy1 < minEdgeLength_) p_edge_(generator_);
        auto dy2 = p_edge_(generator_); while (dy2 < minEdgeLength_) p_edge_(generator_);

        auto dxVec1 = axes[0]; dxVec1 *= dx1/2.0;
        auto dxVec2 = axes[0]; dxVec2 *= dx2/2.0;
        auto dyVec1 = axes[1]; dyVec1 *= dy1/2.0;
        auto dyVec2 = axes[1]; dyVec2 *= dy2/2.0;

        // compute corner points
        const auto c = (*pointSampler_)();
        auto c1 = c; c1 -= dxVec1; c1 -= dyVec1;
        auto c2 = c; c2 += dxVec2; c2 -= dyVec2;
        auto c3 = c; c3 -= dxVec1; c3 += dyVec1;
        auto c4 = c; c4 += dxVec2; c4 += dyVec2;

        return Quadrilateral(c1, c2, c3, c4);
    }

 private:
    std::shared_ptr<PointSampler<Point>> pointSampler_; //!< pointer to the sampler for quadrilateral center points
    std::default_random_engine generator_;              //!< Random number generator

    StrikeDistribution p_strike_; //!< Distribution used for the strike angle
    DipDistribution p_dip_;       //!< Distribution used for the dip angle
    EdgeDistribution p_edge_;     //!< Distribution used for the edge lengths of the quads
    ctype minEdgeLength_;         //!< Minimum allowed length of quadrilateral edges
};

} // end namespace Detail

} // end namespace Frackit

#endif // FRACKIT_QUADRILATERAL_SAMPLER_HH
