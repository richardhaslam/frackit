// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
// vi: set et ts=4 sw=4 sts=4:
/*****************************************************************************
 *   See the file COPYING for full copying permissions.                      *
 *                                                                           *
 *   This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation, either version 2 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
 *****************************************************************************/
/*!
 * \file
 * \brief Class to randomly generate disks in three-
 *        dimensional space. Generation is done on the
 *        basis of probability distribution functions
 *        provided among construction. The type of
 *        distribution function used in the sampler
 *        class can be defined by passing a traits class.
 */
#ifndef FRACKIT_DISK_SAMPLER_HH
#define FRACKIT_DISK_SAMPLER_HH

#include <random>

#include <frackit/common/math.hh>
#include <frackit/geometry/disk.hh>
#include <frackit/geometry/vector.hh>
#include <frackit/geometry/direction.hh>

#include "geometrysampling.hh"

namespace Frackit {

/*!
 * \brief Specialization of the default traits for the disk sampler.
 */
template<class ctype>
struct DefaultSamplerTraits<Disk<ctype>>
{
    // Distribution used for the major axis length
    using MajorAxisLengthDistribution = std::normal_distribution<ctype>;
    // Distribution used for the minor axis length
    using MinorAxisLengthDistribution = std::normal_distribution<ctype>;

    // The following distribution determine the rotation angles
    // around the x-, y- and z- axis that have to be performed
    // subsequently (!) to rotate the standard basis of R^3 into the
    // disk local basis. The disk local basis is defined such that
    // the major axis is the first basis vector, the minor axis
    // the second basis vector and the normal vector the third.
    // We chose this approach as these three parameters can be
    // sampled independently, while the major/minor/normal axes
    // cannot be chosen independently.
    using XAngleDistribution = std::normal_distribution<ctype>;
    using YAngleDistribution = std::normal_distribution<ctype>;
    using ZAngleDistribution = std::normal_distribution<ctype>;
};

/*!
 * \brief Geometry sampler for disks.
 *        The disks are generated by sampling from provided
 *        distributions for:
 *            - major axis length
 *            - minor axis length
 *            - rotation angle of standard basis around x-axis
 *            - rotation angle of standard basis around y-axis
 *            - rotation angle of standard basis around z-axis
 *        The rotation angles are used to define the local basis
 *        of the disk, composed of major axis, minor axis and normal.
 *        The angles state around which angles the standard basis of R^3
 *        has to be rotated around the x-, y- and the z-axis (subsequently!)
 *        for it to describe the disk-local basis. This approach was chosen
 *        since independent sampling of the axis vectors is not possible
 *        due to the requirement that they must form an orthonormal basis.
 */
template< class ctype, class T >
class GeometrySampler< Disk<ctype>, T >
{
    using MajorAxisLengthDistribution = typename T::MajorAxisLengthDistribution;
    using MinorAxisLengthDistribution = typename T::MinorAxisLengthDistribution;
    using XAngleDistribution = typename T::XAngleDistribution;
    using YAngleDistribution = typename T::YAngleDistribution;
    using ZAngleDistribution = typename T::ZAngleDistribution;

    using Vector = Frackit::Vector<ctype, 3>;
    using Direction = Frackit::Direction<ctype, 3>;

public:
    //! export underlying geometry type
    using Disk = Frackit::Disk<ctype>;
    using Geometry = Disk;

    //! export traits class
    using Traits = T;

    /*!
     * \brief Constructor.
     * \param majAxis Distribution used to sample major axis lengths
     * \param minAxis Distribution used to sample minor axis lengths
     * \param xAngle Distribution used to sample the angle of rotation around x-axis
     * \param yAngle Distribution used to sample the angle of rotation around y-axis
     * \param zAngle Distribution used to sample the angle of rotation around z-axis
     * \note For more info on the meaning of the rotation angles, see the description
     *       of this class.
     */
    GeometrySampler(const MajorAxisLengthDistribution& majAxis,
                    const MinorAxisLengthDistribution& minAxis,
                    const XAngleDistribution& xAngle,
                    const YAngleDistribution& yAngle,
                    const ZAngleDistribution& zAngle)
    : generator_(std::random_device{}())
    , p_majorAxisLength_(majAxis)
    , p_minorAxisLength_(minAxis)
    , p_angle_x_(xAngle)
    , p_angle_y_(yAngle)
    , p_angle_z_(zAngle)
    {}

    /*!
     * \brief \todo TODO Doc me.
     */
    template<class PointSampler>
    Disk operator() (PointSampler& pointSampler)
    {
        auto a = p_majorAxisLength_(generator_);
        while (a <= 0.0) a = p_majorAxisLength_(generator_);

        auto b = p_minorAxisLength_(generator_);
        while (b <= 0.0) b = p_minorAxisLength_(generator_);

        if (b > a) b = a;

        const auto c = pointSampler();
        const auto alpha = p_angle_x_(generator_);
        const auto beta = p_angle_y_(generator_);
        const auto gamma = p_angle_z_(generator_);

        // find major/minor axis by rotations
        std::vector<Vector> axes({Vector(1.0, 0.0, 0.0),
                                  Vector(0.0, 1.0, 0.0)});

        auto e1 = Direction(axes[0]);
        auto e2 = Direction(axes[1]);
        auto e3 = Direction(Vector(0.0, 0.0, 1.0));

        rotate(axes[1], e1, alpha); // rotate minor axis around x
        rotate(axes, e2, beta);     // rotate both axes around y

        // minor axis is rotated around y in clockwise direction,
        // therefore fix sign. TODO: Check why this is the case.
        axes[1] = Vector(-1.0*axes[1].x(), axes[1].y(), axes[1].z());

        // rotate both axes around z
        rotate(axes, e3, gamma);

        return Disk(c, Direction(axes[0]), Direction(axes[1]), a, b);
    }

 private:
    std::default_random_engine generator_;

    MajorAxisLengthDistribution p_majorAxisLength_;
    MinorAxisLengthDistribution p_minorAxisLength_;
    XAngleDistribution p_angle_x_;
    YAngleDistribution p_angle_y_;
    ZAngleDistribution p_angle_z_;
};

} // end namespace Frackit

#endif // FRACKIT_DISK_SAMPLER_HH
